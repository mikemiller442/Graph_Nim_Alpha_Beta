import java.util.HashMap;
import java.util.Set;
import java.util.Stack;
import java.util.ArrayList;
import java.util.Scanner;

/*
 * and now an ascii dinosaur
 *              _
 *            / _) ROAR!
 *     .-^^^-/ /
 *  __/       /
 * /__.|_|-|_|
 *
 * thanks for visiting! come again!
 */

public class Group {

	protected int rank;
	protected String type;
	protected int order;
	protected Node token;
	protected Node identity;
	protected HashMap<String, Node> elements;
	protected int playerToMove = 0;
	protected int[] playerStones = new int[2];
	protected Node[] generators;
	protected int numStones;
	protected boolean canPass;
	protected Stack<Move> movesMade;

	/*
	* Rank is the cardinality of the minimal generating set (explained in
	* explanation.txt), and the canPass sets whether or not passing is an option.
	*/
	public Group(int rank, String type, boolean canPass, int numStones) {

		this.rank = rank;
		this.type = type;
		this.elements = new HashMap<String, Node>();
		this.movesMade = new Stack<Move>();
		this.canPass = canPass;
		this.numStones = numStones;

	}

	/*
	* Constructs all of the elements in the group using the abstracted
	* compose operation present in the abstract class Node and implemented
	* in each derived class of the group elements.
	*
	* The algorithm to generate all the elements is to repeatedly multiply
	* everything currently generated by the generators and hope you generate
	* everything. It seems to work for every case except large Abelian groups,
	* which I will explore.
	*/
	public void generateElements () {

		Node tempGroupElement;
		Node preimage;
		Node groupAction;
		String elementKey = "";
		ArrayList<Node> generatedElements = new ArrayList<Node>();
		Set<String> currentElementKeys;

		while (this.elements.size() < this.order) {

			System.out.println(this.elements.size());
			currentElementKeys = this.elements.keySet();

			for (String key:currentElementKeys) {

				for (int i = 0; i < this.generators.length; i++) {

					preimage = this.elements.get(key);
					tempGroupElement = preimage.compose(this.generators[i], this.numStones);
					elementKey = tempGroupElement.generateKey();

					if (!this.elements.containsKey(elementKey)) {

						generatedElements.add(tempGroupElement);

					}

				}

			}

			for (int i = 0; i < generatedElements.size(); i++) {

				if (!this.elements.containsKey(generatedElements.get(i).getKey())) {

					this.elements.put(generatedElements.get(i).getKey(), generatedElements.get(i));

				}

			}

			generatedElements.clear();

		}

	}

	/*
	* Constructs the edges in the graph using the simple algorithm given
	* in explanation.txt.
	*/
	public void ConstructEdges() {

		Node preimage;
		Node tempImage;
		Node image;
		String imageKey;
		Set<String> keys = this.elements.keySet();
		for (String key:keys) {

			preimage = this.elements.get(key);
			for(int i = 0; i < this.generators.length; i++) {

				tempImage = preimage.compose(this.generators[i], this.numStones);
				imageKey = tempImage.generateKey();
				image = this.elements.get(imageKey);

				String[] preimages = image.getPreimages();

				preimage.addImage(imageKey);
				image.addPreimage(key);

			}

		}

	}

	public void PrintVertices() {

		Set<String> currentElementKeys = this.elements.keySet();
		for (String key:currentElementKeys) {

			System.out.println(key);

		}

	}

	public void PrintGraph() {

		Node tempNode;
		Node imageNode;
		String[] images;
		String outputString = "";
		String imageString;

		Set<String> currentElementKeys = this.elements.keySet();
		for (String key:currentElementKeys) {

			tempNode = this.elements.get(key);
			outputString = tempNode.getKey() + ":";
			images = tempNode.getImages();
			for (int i = 0; i < images.length; i++) {

				imageNode = this.elements.get(images[i]);
				outputString = outputString + " " + imageNode.getKey() + ", weight = " + Integer.toString(imageNode.getWeight()) + ",";

			}

			System.out.println(outputString.substring(0, outputString.length() - 1));

		}

		System.out.println("Player one stones removed: " + Integer.toString(this.playerStones[0]));
		System.out.println("Player two stones removed: " + Integer.toString(this.playerStones[1]));
		System.out.println("Player to move: " + Integer.toString(playerToMove + 1));
		System.out.println("Token: " + this.token.getKey());
		System.out.println("Number of tokens: " + this.order);

	}

	public void startGame(Group graphNim) {

		this.token = this.identity;
		this.playerStones[0] = 0;
		this.playerStones[1] = 0;

	}

	public HashMap<String, Node> getElements() {

		return this.elements;

	}

	public int getRank() {

		return this.rank;

	}

	public String getType() {

		return this.type;

	}

	public int getPlayerToMove() {

		return this.playerToMove;

	}

	public Node getNode(String key) {

		return this.elements.get(key);

	}

	public Node getToken() {

		return this.token;

	}

	public int[] getPlayerStones() {

		return this.playerStones;

	}

	public ArrayList<Move> getMoves() {

		Move tempMove;
		Node tempNode;
		ArrayList<Move> moves = new ArrayList<Move>();
		String[] images = this.token.getImages();

		if (this.playerStones[playerToMove] > this.playerStones[(this.playerToMove + 1) % 2] & this.canPass & this.token.getWeight() != 0) {

			tempMove = new Move(this.playerToMove, 0, this.token.getKey(), this.token.getKey());
			moves.add(tempMove);

		}

		for (int i = 0; i < images.length; i++) {

			for (int j = 1; j <= this.token.getWeight(); j++) {

				tempNode = this.elements.get(images[i]);
				tempMove = new Move(this.playerToMove, j, this.token.getKey(), tempNode.getKey());
				moves.add(tempMove);

			}

		}

		return moves;

	}

	public void makeMove(Move move) {

		System.out.println("trying to make a move");
		System.out.println("move image");
		System.out.println(move.getImage());

		try {

			this.token.decreaseWeight(move.getWeight());
			this.token = this.elements.get(move.getImage());
			this.playerStones[move.getPlayerToMove()] = this.playerStones[move.getPlayerToMove()] + move.getWeight();
			this.playerToMove = (this.playerToMove + 1) % 2;
			this.movesMade.push(move);

			System.out.println("pushed move onto the stack");

		} catch(Exception e) {

			e.printStackTrace();
			System.exit(0);

		}

	}

	public void undoMove() {

		Move move = this.movesMade.pop();
		int playerToMove = move.getPlayerToMove();
		int stoneDecrement = move.getWeight();
		String preimage = move.getPreimage();
		String image = move.getImage();

		this.token = this.elements.get(preimage);
		this.token.increaseWeight(stoneDecrement);
		this.playerStones[playerToMove] = this.playerStones[playerToMove] - stoneDecrement;
		this.playerToMove = playerToMove;

		System.out.println("player stones");
		System.out.println(this.playerStones[0]);
		System.out.println(this.playerStones[1]);

	}

	public void setDiscoveredStatus(boolean isDiscovered) {

		Node tempElement;
		Set<String> currentElementKeys = this.elements.keySet();
		for (String key:currentElementKeys) {

			tempElement = this.elements.get(key);
			tempElement.setDiscovered(isDiscovered);

		}

	}

	public static void main(String[] args) {

		System.out.println("Hello World!");
		boolean isValid = false;
		Move move;
		Node image;
		String imageKey = "";
		String[] images;
		int stoneDecrement = 0;
		Scanner scn = new Scanner(System.in);

		/*
		* Below are the game options.
		*/

		//Abelian Group Game
		int[] products = new int[1];
		products[0] = 4;
		// products[1] = 4;
		// products[2] = 16;
		Group graphNim = new AbelianGroup(1, "Abelian", true, 4, products);

		// Symmetric Group game
		// Group graphNim = new SymmetricGroup(2, "Symmetric", true, 4, 3);

		//Matrix Group Game
		// Group graphNim = new MatrixGroup(2, "Matrix", true, 2, 4, 3);

		/*
		* The game options are avaiable above.
		*/

		graphNim.startGame(graphNim);

		while (!graphNim.getMoves().isEmpty()) {

			graphNim.PrintGraph();
			while (!isValid) {

				isValid = false;
				if (!graphNim.canPass) {
					System.out.println("Make a move by first entering the key of the vertex");
				} else {
					System.out.println("Make a move by first entering the key of the vertex OR enter 'pass' if you have taken more stones than your opponent:");
				}
				System.out.println("Available vertices to move to: ");
				graphNim.token.printImages();
				imageKey = scn.nextLine();
				if (imageKey.equals("pass") && graphNim.canPass) {

					if (graphNim.playerStones[graphNim.playerToMove] > graphNim.playerStones[(graphNim.playerToMove + 1) % 2]) {

						stoneDecrement = 0;
						imageKey = graphNim.token.getKey();
						isValid = true;

					} else {

						System.out.println("You do not have more stones than your oppponent and therefore cannot pass.");

					}

				} else {

					// graphNim.PrintVertices();
					if (graphNim.elements.containsKey(imageKey)) {

						images = graphNim.token.getImages();
						if (graphNim.token.containsImage(imageKey)) {

							System.out.println("Now enter how many stones you would like to remove from your current vertex:");
							stoneDecrement = Integer.parseInt(scn.nextLine());
							System.out.println(stoneDecrement);
							while (stoneDecrement > graphNim.token.getWeight() || stoneDecrement <= 0) {

								System.out.println("Enter a valid amount of stones to remove.");
								stoneDecrement = Integer.parseInt(scn.nextLine());

							}
							isValid = true;

						} else {

							System.out.println("The input image is not adjacent to the token.");

						}

					} else {

						System.out.println("This was not a valid key.");

					}

				}

			}

			move = new Move(graphNim.getPlayerToMove(), stoneDecrement, graphNim.token.getKey(), imageKey);
			System.out.println("About to make a move");
			graphNim.makeMove(move);
			System.out.println("Successfully made a move");
			isValid = false;

		}

		if ((graphNim.playerToMove + 1) % 2 == 0) {

			System.out.println("Congratulations to player one who has won the game!");

		} else {

			System.out.println("Congratulations to player two who has won the game!");

		}

	}

}
